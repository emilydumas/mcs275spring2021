# -*- coding: utf-8 -*-
"""decorators.ipynb

Automatically generated by Colaboratory.

The ipynb file is on github:
https://raw.githubusercontent.com/emilydumas/mcs275spring2021/master/samplecode/decorators.ipynb

Running this file directly with the python interpreter will work up until the first line that
creates an exception, at which point it will exit.  Comment out the exception-generating
example to run everything below it, too.


# MCS 275 Spring 2021 Lecture 8
## Live coding decorator examples
"""

# A higher-order function: It accepts a function as an argument
def dotwice(f):
    """Call function f twice"""
    f()
    f()

def eureka():
  """Shout eureka"""
  print("Eureka! I have discovered Python!")

dotwice(eureka)

# The next line will NOT work, because eureka() evaluates to None
# and None is not callable.
dotwice(eureka())  # call eureka, get return value, pass that to dotwice

# This is basically what's wrong with the cell above
# A non-callable object is being called
275("this will fail")

def sayhello():
  """Say hello"""
  print("hello")

dotwice(sayhello)

# lamba arg1,arg2: retval
dotwice(lambda :print("hello"))

# A version of dowtice that allows the function to be called
# to accept arbitrary parameters

def dotwice2(f,*args,**kwargs):
    """Call function f twice, allowing arguments to be passed"""
    f(*args,**kwargs)
    f(*args,**kwargs)

dotwice2(print,"hello","my name","is","david",end="!\n")

# Previous cell equivalent to
print("hello","my name","is","david",end="!\n")
print("hello","my name","is","david",end="!\n")

def return_power(n):
    def inner(x): # function inside a function!
        """Raise x to a power"""
        return x**n
    return inner

pow2 = return_power(2)  # 2 goes into n, and inner gets defined & returned
pow3 = return_power(3)  # 3 goes into n, and inner gets defined & returned

# pow2 and pow3 are nice names, but you can use any name you like
alice = return_power(10)

alice(2)

# Let's make a function that turns functions into functions
# In this case, it turns f into a new function that just calls f twice.
def return_twice_doer(f):
    """Return a new function which calls f twice"""
    def inner(*args,**kwargs):
        """Call a certain function twice"""
        f(*args,**kwargs)
        f(*args,**kwargs)
    return inner

def eureka():
  """Shout eureka"""
  print("Eureka! I have discovered Python!")

eureka_twice = return_twice_doer(eureka)

eureka_twice()

# Another way to use return_twice_doer is to 
# build a function and then REPLACE that with 
# the modified version created by return_twice_doer, e.g.

def hi():
  """Informal greeting"""
  print("Hi.")

# obliterate the original definition of `hi`
# replacing it with a new function that prints "Hi." twice
hi = return_twice_doer(hi)

hi()

# Decorator syntax is just a shorthand for defining
# and then immediately modifying a function
# e.g.

@return_twice_doer
def hello():
  """Say hello"""
  print("Hello.  I hope you are having a good week.")

# The block above is equivalent to the function definition without
# @return_twice_doer followed by:
# hello = return_twice_doer(hello)

# The decorator has modified hello() so it actually runs twice!
# hello()

# Another decorator example
def fnlog(f):
  """Decorator that adds a message to each function call"""
  def flogged(*args,**kwargs):
    """Call a function, but with a message before and after."""
    print("I am about to call {}.".format(f.__name__))
    ret = f(*args,**kwargs)
    print("I just called {}.".format(f.__name__))
    return ret  # Whatever f returned, we return too
  return flogged

# Using the fnlog decorator example

@fnlog
def goodbye():
  """Say goodbye"""
  print("Bye!")

@fnlog
def count_to(n):
  """Print the integers from 1 to n inclusive"""
  for i in range(n):
    print(i+1)

@fnlog
def square(x):
  """Square a number"""
  return x*x

goodbye()

count_to(5)

square(6)

"""### Decorators in the Python standard library"""

import time
import functools

@functools.lru_cache(100)
def slow_square(x):
  """Square x, but take a long time to do it"""
  time.sleep(2)
  return x*x

# This will take a while, because it's the first time
print("Computing 7*7 for the first time:")
print(slow_square(7))

# But this will be quick, because the value is remembered
# by the LRU cache decorator
print("Computing 7*7 for the second time:")
print(slow_square(7))